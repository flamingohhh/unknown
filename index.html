<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GVG Attack Planner</title>
  <style>
    :root{
      --border:#e6e6e7; --text:#111; --muted:#666; --bg:#fff;
      --astra:#2563eb; --luna:#7c3aed; --sola:#16a34a; --rex:#dc2626;
      --w3:#e11d48; --w2:#f59e0b; --w1:#22c55e; --w0:#64748b;
    }
    *{ box-sizing:border-box; }
    body{ font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:14px; color:var(--text); background:var(--bg); }
    h1{ margin:0 0 10px; font-size:18px; }
    h2{ margin:14px 0 8px; font-size:15px; }
    .card{ border:1px solid var(--border); border-radius:14px; padding:12px; margin:10px 0; background:#fff; box-shadow:0 1px 0 rgba(0,0,0,.03); }
    label{ display:block; font-size:12px; margin-bottom:6px; }
    select{
      width:100%;
      padding:10px 12px;
      border:1px solid #d7d7da;
      border-radius:12px;
      font-size:14px;
      background:#fff;
    }
    button{
      width:100%;
      padding:12px 14px;
      border:0;
      border-radius:14px;
      background:#111;
      color:#fff;
      font-weight:700;
      font-size:15px;
      cursor:pointer;
    }
    button:hover{ opacity:.92; }
    pre{
      background:#0b0b0b; color:#eaeaea;
      padding:12px; border-radius:14px;
      overflow:auto; white-space:pre-wrap;
      font-size:12px; word-break:break-word;
      margin:0;
    }
    .ok{ color:#0b7a0b; font-weight:700; }
    .bad{ color:#b00020; font-weight:700; }
    .muted{ color:var(--muted); font-size:12px; }

    .cityCard{ border-left:8px solid transparent; }
    .cityCard.astra{ border-left-color:var(--astra); }
    .cityCard.luna{ border-left-color:var(--luna); }
    .cityCard.sola{ border-left-color:var(--sola); }
    .cityCard.rex{ border-left-color:var(--rex); }

    .cityHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:10px; flex-wrap:wrap;
    }
    .cityTitle{
      display:flex; align-items:center; gap:10px;
      font-weight:800; font-size:14px;
    }
    .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
    .dot.astra{ background:var(--astra); }
    .dot.luna{ background:var(--luna); }
    .dot.sola{ background:var(--sola); }
    .dot.rex{ background:var(--rex); }
    .slots{ font-size:12px; color:var(--muted); white-space:nowrap; }

    .row{ display:grid; grid-template-columns: 1fr; gap:10px; }
    @media (min-width: 900px){
      body{ margin:18px; }
      h1{ font-size:20px; }
      .row{ grid-template-columns: 1fr 1fr; }
    }

    .helperLine{ margin-top:8px; font-size:12px; font-weight:700; }
    .helperLine.ok{ color:#0b7a0b; }
    .helperLine.bad{ color:#b00020; }

    .kLine{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:8px;
      margin-top:10px;
    }
    @media (max-width: 520px){
      .kLine{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    .kField label{
      margin-bottom:4px;
      font-size:11px;
      display:flex; align-items:center; gap:6px;
      white-space:nowrap;
    }
    .kField select{ padding:8px 10px; border-radius:10px; font-size:13px; }
    .kd{ width:10px; height:10px; border-radius:999px; display:inline-block; }
    .kd.w3{ background:var(--w3); }
    .kd.w2{ background:var(--w2); }
    .kd.w1{ background:var(--w1); }
    .kd.w0{ background:var(--w0); }

    .tabs{ display:flex; gap:8px; flex-wrap:wrap; }
    .tabBtn{
      flex:1; min-width:110px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#f6f6f7;
      font-weight:800;
      cursor:pointer;
      text-align:center;
      user-select:none;
    }
    .tabBtn.active{ background:#111; color:#fff; border-color:#111; }
    .tabPanel{ display:none; margin-top:10px; }
    .tabPanel.active{ display:block; }

    .miniGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:8px;
      margin-top:10px;
      margin-bottom:10px;
    }
    @media (max-width: 520px){
      .miniGrid{ grid-template-columns: 1fr; }
    }
    .miniBox{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      background:#fcfcfd;
      font-size:12px;
    }
    .miniBox b{ font-size:13px; }
  </style>
</head>
<body>
  <h1>GVG Attack Planner</h1>

  <div class="card">
    <h2>Attackers</h2>
    <label>Count</label>
    <select id="attackers"></select>
  </div>

  <div class="card">
    <h2>City Setup</h2>
    <div id="cities"></div>
    <div style="margin-top:10px;">
      <button id="calcBtn">Calculate</button>
    </div>
  </div>

  <div class="card">
    <h2>Plans</h2>
    <div class="tabs">
      <div class="tabBtn active" data-tab="k1">1 Subcity</div>
      <div class="tabBtn" data-tab="k2">2 Subcities</div>
      <div class="tabBtn" data-tab="k3">3 Subcities</div>
    </div>

    <div id="status" class="muted" style="margin-top:8px;">Press “Calculate”.</div>

    <div id="k1" class="tabPanel active">
      <div class="miniGrid" id="k1_boxes"></div>
      <pre id="k1_out"></pre>
    </div>

    <div id="k2" class="tabPanel">
      <div class="miniGrid" id="k2_boxes"></div>
      <pre id="k2_out"></pre>
    </div>

    <div id="k3" class="tabPanel">
      <div class="miniGrid" id="k3_boxes"></div>
      <pre id="k3_out"></pre>
    </div>
  </div>

<script>
/* =======================
   TABLES
   ======================= */
const ATTACKS_PER_ATTACKER_PER_ROUND = 10;

const NORMAL_DEF_COST = { "3w":10, "2w":15, "1w":20, "0w":60 };

const REX_OTHER_DEF_COST_BY_ALIVE = {
  3: { "3w":100, "2w":150, "1w":200, "0w":600 },
  2: { "3w":25,  "2w":38,  "1w":50,  "0w":150 },
  1: { "3w":15,  "2w":22,  "1w":28,  "0w":75  },
  0: { "3w":10,  "2w":15,  "1w":20,  "0w":60  }
};

const CITY_STRUCT = {
  Astra: { outposts:7, camps:3, barrier:1 },
  Luna:  { outposts:7, camps:3, barrier:1 },
  Sola:  { outposts:9, camps:3, barrier:1 },
  Rex:   { outposts:11, camps:3, barrier:1 }
};

const CITY_LIMITS = { Astra:11, Luna:11, Sola:13, Rex:15 };

const STRUCT_COST = { outpost:5, camp:10, barrier:5 };

const REX_STRUCT_COST_BY_ALIVE = {
  3: { outpost:50, camp:100, barrier:5 },
  2: { outpost:13, camp:25,  barrier:5 },
  1: { outpost:8,  camp:15,  barrier:5 },
  0: { outpost:5,  camp:10,  barrier:5 }
};

const W_LEVELS = ["3w","2w","1w","0w"];
const CITY_ORDER = ["Astra","Luna","Sola","Rex"];
const SUBCITIES = ["Astra","Luna","Sola"];
const CITY_CLASS = { Astra:"astra", Luna:"luna", Sola:"sola", Rex:"rex" };

/* =======================
   UI
   ======================= */
function optionList(max, selected){
  let html="";
  for (let i=0;i<=max;i++){
    html += `<option value="${i}" ${i===selected?"selected":""}>${i}</option>`;
  }
  return html;
}
function attackersOptions(){
  const sel = document.getElementById("attackers");
  let html="";
  for (let i=1;i<=100;i++){
    html += `<option value="${i}" ${i===44?"selected":""}>${i}</option>`;
  }
  sel.innerHTML = html;
}
function barrierSelect(id){
  return `
    <select id="${id}">
      <option value="none">No barrier</option>
      <option value="3w">3w</option>
      <option value="2w">2w</option>
      <option value="1w" selected>1w</option>
      <option value="0w">0w</option>
    </select>
  `;
}
function cityBlock(name){
  const limit = CITY_LIMITS[name];
  const cls = CITY_CLASS[name];
  return `
    <div class="card cityCard ${cls}">
      <div class="cityHeader">
        <div class="cityTitle"><span class="dot ${cls}"></span>${name}</div>
        <div class="slots">Slots: <b id="${name}_slotsUsed">0</b> / ${limit}</div>
      </div>

      <div class="row">
        <div>
          <label>Barrier Kraken</label>
          ${barrierSelect(`${name}_barrier`)}
        </div>

        <div>
          <label>Other Krakens</label>
          <div class="kLine">
            <div class="kField">
              <label><span class="kd w3"></span>3w</label>
              <select id="${name}_other_3w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w2"></span>2w</label>
              <select id="${name}_other_2w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w1"></span>1w</label>
              <select id="${name}_other_1w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w0"></span>0w</label>
              <select id="${name}_other_0w"></select>
            </div>
          </div>
          <div class="helperLine" id="${name}_remaining"></div>
        </div>
      </div>
    </div>
  `;
}

/* =======================
   INPUT STATE / SLOTS
   ======================= */
function clampInt(v, lo, hi){
  v = Number.isFinite(v) ? Math.floor(v) : lo;
  return Math.max(lo, Math.min(hi, v));
}
function getCitySetup(name){
  const barrierVal = document.getElementById(`${name}_barrier`).value;
  const barrier = (barrierVal === "none") ? null : barrierVal;
  const other = {};
  for (const w of W_LEVELS){
    const raw = parseInt(document.getElementById(`${name}_other_${w}`).value,10);
    other[w] = clampInt(raw, 0, 999);
  }
  return { barrier, other };
}
function totalDefenders(setup){
  let sum = 0;
  for (const w of W_LEVELS) sum += (setup.other[w]||0);
  if (setup.barrier) sum += 1;
  return sum;
}
function updateDropdownMax(name){
  const limit = CITY_LIMITS[name];
  const maxOther = Math.max(0, limit - 1);
  for (const w of W_LEVELS){
    const el = document.getElementById(`${name}_other_${w}`);
    const cur = clampInt(parseInt(el.value,10), 0, 999);
    const safe = Math.min(cur, maxOther);
    el.innerHTML = optionList(maxOther, safe);
  }
}
function updateRemaining(name){
  const setup = getCitySetup(name);
  const used = totalDefenders(setup);
  const limit = CITY_LIMITS[name];
  const remaining = limit - used;

  document.getElementById(`${name}_slotsUsed`).textContent = used;

  const el = document.getElementById(`${name}_remaining`);
  if (remaining >= 0){
    el.className = "helperLine ok";
    el.innerHTML = `Remaining: <b>${remaining}</b>`;
  } else {
    el.className = "helperLine bad";
    el.innerHTML = `Too many — reduce <b>${-remaining}</b>`;
  }
}

/* =======================
   SUBCITY (ORDER FIX)
   barrier kraken -> barrier structure -> everything else
   ======================= */
function subcityOtherStructuresCost(city){
  const c = CITY_STRUCT[city];
  return c.outposts*STRUCT_COST.outpost + c.camps*STRUCT_COST.camp; // exclude barrier structure
}
function fullClearSubcity(city, setup){
  const parts = [];
  let total = 0;

  // 1) barrier kraken
  if (setup.barrier){
    const cost = NORMAL_DEF_COST[setup.barrier];
    parts.push({ label:`Kill ${city} barrier (${setup.barrier})`, cost });
    total += cost;
  }

  // 2) barrier structure
  parts.push({ label:`Destroy ${city} barrier structure`, cost: STRUCT_COST.barrier });
  total += STRUCT_COST.barrier;

  // 3) other krakens
  for (const w of W_LEVELS){
    const n = setup.other[w] || 0;
    if (n>0){
      const cost = n * NORMAL_DEF_COST[w];
      parts.push({ label:`Kill ${city} ${w} ×${n}`, cost });
      total += cost;
    }
  }

  // 4) remaining structures
  const otherStruct = subcityOtherStructuresCost(city);
  parts.push({ label:`Destroy ${city} outposts+camps`, cost: otherStruct });
  total += otherStruct;

  return { total, parts };
}

// Partial work model for k=3 (same gate order)
function buildSubcityWork(city, setup){
  const work = [];

  // stage0: barrier kraken
  if (setup.barrier){
    work.push({ stage:0, label:`Kill ${city} barrier (${setup.barrier})`, remaining: NORMAL_DEF_COST[setup.barrier] });
  }

  // stage1: barrier structure
  work.push({ stage:1, label:`Destroy ${city} barrier structure`, remaining: STRUCT_COST.barrier });

  // stage2: other krakens
  for (const w of W_LEVELS){
    const n = setup.other[w] || 0;
    for (let i=0;i<n;i++){
      work.push({ stage:2, label:`Kill ${city} ${w}`, remaining: NORMAL_DEF_COST[w] });
    }
  }

  // stage3: other structures
  const c = CITY_STRUCT[city];
  for (let i=0;i<c.outposts;i++) work.push({ stage:3, label:`Destroy ${city} outpost`, remaining: STRUCT_COST.outpost });
  for (let i=0;i<c.camps;i++)   work.push({ stage:3, label:`Destroy ${city} camp`,   remaining: STRUCT_COST.camp });

  return work;
}

function spendSubcityForRound(work, budget){
  let spent = 0;
  const steps = [];

  const spendInto = (item, amount) => {
    const use = Math.min(amount, item.remaining);
    if (use<=0) return 0;
    item.remaining -= use;
    spent += use;
    steps.push({ label: item.label + (item.remaining>0 ? " (partial)" : ""), spent: use });
    return use;
  };

  // stage0
  const gate0 = work.find(x=>x.stage===0);
  if (gate0 && gate0.remaining>0 && budget>0){
    budget -= spendInto(gate0, budget);
  }
  const gate0Done = !gate0 || gate0.remaining===0;

  // stage1 (barrier structure)
  const gate1 = work.find(x=>x.stage===1);
  if (gate0Done && gate1.remaining>0 && budget>0){
    budget -= spendInto(gate1, budget);
  }
  const gate1Done = gate1.remaining===0;

  // rest: stage2 then stage3 in list order
  if (gate0Done && gate1Done && budget>0){
    const rest = work.filter(x=>x.stage>=2 && x.remaining>0);
    for (const it of rest){
      if (budget<=0) break;
      budget -= spendInto(it, budget);
    }
  }

  const done = work.every(x=>x.remaining<=1e-9);
  return { spent, steps, unused: budget, done };
}

/* =======================
   REX (already correct gate order)
   ======================= */
function buildRexWork(setupRex, aliveA1, aliveA2){
  const work = [];

  // stage0: barrier kraken (NORMAL cost)
  if (setupRex.barrier){
    work.push({ stage:0, label:`Kill Rex barrier (${setupRex.barrier})`, remaining: NORMAL_DEF_COST[setupRex.barrier] });
  }

  // stage1: barrier structure (REX table)
  work.push({ stage:1, label:`Destroy Rex barrier structure`, remaining: REX_STRUCT_COST_BY_ALIVE[aliveA1].barrier });

  // stage2: other defenders (per alive)
  for (const w of W_LEVELS){
    const n = setupRex.other[w] || 0;
    if (n<=0) continue;
    const per1 = REX_OTHER_DEF_COST_BY_ALIVE[aliveA1][w];
    const per2 = REX_OTHER_DEF_COST_BY_ALIVE[aliveA2][w];
    for (let i=0;i<n;i++){
      work.push({ stage:2, key:`def_${w}_${i}`, labelBase:`Kill Rex ${w}`, remaining: per1, per1, per2 });
    }
  }

  // stage3: outposts + camps (per alive). (barrier structure already stage1)
  const out1 = REX_STRUCT_COST_BY_ALIVE[aliveA1].outpost;
  const out2 = REX_STRUCT_COST_BY_ALIVE[aliveA2].outpost;
  for (let i=0;i<CITY_STRUCT.Rex.outposts;i++){
    work.push({ stage:3, key:`out_${i}`, labelBase:`Destroy Rex outpost`, remaining: out1, per1: out1, per2: out2 });
  }

  const camp1 = REX_STRUCT_COST_BY_ALIVE[aliveA1].camp;
  const camp2 = REX_STRUCT_COST_BY_ALIVE[aliveA2].camp;
  for (let i=0;i<CITY_STRUCT.Rex.camps;i++){
    work.push({ stage:3, key:`camp_${i}`, labelBase:`Destroy Rex camp`, remaining: camp1, per1: camp1, per2: camp2 });
  }

  return work;
}

function spendRexForRound(workState, budget, aliveLabel){
  let spentTotal = 0;
  const steps = [];

  const spendInto = (item, amount, label) => {
    const use = Math.min(amount, item.remaining);
    if (use<=0) return 0;
    item.remaining -= use;
    spentTotal += use;
    steps.push({ label: label + (item.remaining>0 ? " (partial)" : ""), spent: use });
    return use;
  };

  // stage0
  const gate0 = workState.find(x=>x.stage===0);
  if (gate0 && gate0.remaining>0 && budget>0){
    budget -= spendInto(gate0, budget, gate0.label);
  }
  const gate0Done = !gate0 || gate0.remaining===0;

  // stage1
  const gate1 = workState.find(x=>x.stage===1);
  if (gate0Done && gate1.remaining>0 && budget>0){
    budget -= spendInto(gate1, budget, gate1.label);
  }
  const gate1Done = gate1.remaining===0;

  // stage2 then stage3
  if (gate0Done && gate1Done && budget>0){
    const stage2 = workState.filter(x=>x.stage===2 && x.remaining>0);
    // keep the old "best to push" sort inside defenders
    stage2.sort((a,b)=>{
      const da = (a.per1-a.per2), db = (b.per1-b.per2);
      if (da!==db) return da-db;
      return 0;
    });
    for (const it of stage2){
      if (budget<=0) break;
      budget -= spendInto(it, budget, `${it.labelBase} (alive=${aliveLabel})`);
    }
    const stage3 = workState.filter(x=>x.stage===3 && x.remaining>0);
    stage3.sort((a,b)=>{
      const da = (a.per1-a.per2), db = (b.per1-b.per2);
      if (da!==db) return da-db;
      return 0;
    });
    for (const it of stage3){
      if (budget<=0) break;
      budget -= spendInto(it, budget, `${it.labelBase} (alive=${aliveLabel})`);
    }
  }

  return { spentTotal, steps, unusedBudget: budget };
}

function rexTotalCostAlive0(setupRex){
  let total = 0;

  // barrier kraken
  if (setupRex.barrier) total += NORMAL_DEF_COST[setupRex.barrier];

  // barrier structure (alive=0)
  total += REX_STRUCT_COST_BY_ALIVE[0].barrier;

  // other defenders (alive=0 uses original NORMAL values from table)
  for (const w of W_LEVELS) total += (setupRex.other[w]||0) * REX_OTHER_DEF_COST_BY_ALIVE[0][w];

  // outposts + camps (alive=0)
  total += CITY_STRUCT.Rex.outposts * REX_STRUCT_COST_BY_ALIVE[0].outpost;
  total += CITY_STRUCT.Rex.camps   * REX_STRUCT_COST_BY_ALIVE[0].camp;

  return total;
}

/* =======================
   SUBSETS
   ======================= */
function allSubsets(arr){
  const out=[], n=arr.length;
  for (let mask=0; mask<(1<<n); mask++){
    const s=[];
    for (let i=0;i<n;i++) if (mask&(1<<i)) s.push(arr[i]);
    out.push(s);
  }
  return out;
}

/* =======================
   BEST FOR k=1/2
   ======================= */
function computeBestForK(setups, cityClear, perRound, k){
  let best = null;

  for (const S1 of allSubsets(SUBCITIES)){
    if (S1.length > k) continue;
    const costS1 = S1.reduce((a,c)=>a+cityClear[c].total,0);
    if (costS1 > perRound) continue;

    const remainingCities = SUBCITIES.filter(c=>!S1.includes(c));
    const needInR2 = k - S1.length;

    for (const S2 of allSubsets(remainingCities)){
      if (S2.length !== needInR2) continue;
      const costS2 = S2.reduce((a,c)=>a+cityClear[c].total,0);
      if (costS2 > perRound) continue;

      const aliveA1 = 3 - S1.length;
      const aliveA2 = 3 - k;

      const b1Rex = perRound - costS1;
      const b2Rex = perRound - costS2;

      const rexStateAfterR1 = buildRexWork(setups.Rex, aliveA1, aliveA2);
      const r1Spend = spendRexForRound(rexStateAfterR1, b1Rex, aliveA1);

      // Remaining Rex required in R2 (exact remaining in R2 units is hard with partial + per2; we show via R2 simulation)
      // We'll simulate R2 spending in R2 "units" by rebuilding Rex at aliveA2 with the remaining fraction.
      // Simpler + consistent: show what happens if you spend b2Rex in R2 after R1.
      const rexR2State = (() => {
        // Convert remaining from (aliveA1 units) into (aliveA2 units) by proportion per item.
        const st = [];
        for (const it of rexStateAfterR1){
          if (it.stage===0 || it.stage===1){
            st.push({ ...it });
          } else {
            const frac = it.per1>0 ? (it.remaining/it.per1) : 0;
            const rem2 = frac * it.per2;
            st.push({
              stage: it.stage,
              key: it.key,
              labelBase: it.labelBase,
              remaining: rem2,
              per1: it.per2,
              per2: it.per2
            });
          }
        }
        return st;
      })();

      const r2Spend = spendRexForRound(rexR2State, b2Rex, aliveA2);
      const rexRemainAfterR2 = (() => {
        let t=0;
        for (const it of rexR2State) t += it.remaining;
        return t;
      })();

      const r1Used = costS1 + r1Spend.spentTotal;
      const r2UsedMax = costS2 + r2Spend.spentTotal;
      const r2ReqToWin = costS2 + (b2Rex - r2Spend.unusedBudget) + rexRemainAfterR2; // sub + rexSpent + rexRemaining
      const totalReq = r1Used + r2ReqToWin;

      const feasible = (r2ReqToWin <= perRound + 1e-9);

      const r2Over = Math.max(0, r2ReqToWin - perRound);
      const r2Slack = Math.max(0, perRound - r2ReqToWin);

      const r1Steps=[];
      for (const c of SUBCITIES) if (S1.includes(c)) r1Steps.push(...cityClear[c].parts.map(p=>({label:p.label,spent:p.cost})));
      r1Steps.push(...r1Spend.steps);

      const r2Steps=[];
      for (const c of SUBCITIES) if (S2.includes(c)) r2Steps.push(...cityClear[c].parts.map(p=>({label:p.label,spent:p.cost})));
      r2Steps.push(...r2Spend.steps);
      if (rexRemainAfterR2 > 1e-9){
        r2Steps.push({ label:`Rex remaining after R2`, spent: Math.round(rexRemainAfterR2*1000)/1000 });
      }

      const better = (!best)
        || (totalReq < best.totalReq - 1e-9)
        || (Math.abs(totalReq-best.totalReq)<=1e-9 && (feasible && !best.feasible))
        || (Math.abs(totalReq-best.totalReq)<=1e-9 && feasible===best.feasible && r2Over < best.r2Over - 1e-9)
        || (Math.abs(totalReq-best.totalReq)<=1e-9 && feasible===best.feasible && Math.abs(r2Over-best.r2Over)<=1e-9 && r2Slack > best.r2Slack + 1e-9);

      if (!better) continue;

      best = {
        k, S1, S2,
        aliveA1, aliveA2,
        r1Used,
        r2Req: r2ReqToWin,
        feasible,
        totalReq,
        r2Over, r2Slack,
        r1Spend,
        r1Steps, r2Steps
      };
    }
  }

  return best;
}

/* =======================
   BEST FOR k=3 (FIXED TOTALS)
   Rule: no Rex until all 3 subcities are down.
   Total required = totalSubCost + totalRexCost(alive=0).
   R1 uses up to perRound on subcities.
   R2 uses remaining subcity cost first, then Rex (alive=0).
   ======================= */
function computeBestFor3(setups, perRound){
  // Choose an order just for clean steps (cheapest first)
  const full = {};
  for (const c of SUBCITIES) full[c] = fullClearSubcity(c, setups[c]);
  const order = SUBCITIES.slice().sort((a,b)=>full[a].total - full[b].total);

  const totalSubCost = SUBCITIES.reduce((s,c)=>s + full[c].total, 0);
  const totalRexCost = rexTotalCostAlive0(setups.Rex);
  const totalReq = totalSubCost + totalRexCost;

  // Build partial subcity work for step simulation
  const work = {};
  for (const c of SUBCITIES) work[c] = buildSubcityWork(c, setups[c]);

  // Round 1: spend on subcities only (in order), no Rex
  let b1 = perRound;
  const r1Steps = [];
  const doneR1 = new Set();

  for (const c of order){
    if (b1<=0) break;
    const res = spendSubcityForRound(work[c], b1);
    b1 = res.unused;
    r1Steps.push(...res.steps);
    if (res.done) doneR1.add(c);
  }
  const S1 = SUBCITIES.filter(c=>doneR1.has(c));

  const r1Used = perRound - b1;
  const r1Waste = b1; // cannot go to Rex in k=3 plan

  // Round 2: finish remaining subcities first
  let b2 = perRound;
  const r2Steps = [];
  const doneR2 = new Set(doneR1);

  for (const c of order){
    if (b2<=0) break;
    if (doneR2.has(c)) continue;
    const res = spendSubcityForRound(work[c], b2);
    b2 = res.unused;
    r2Steps.push(...res.steps);
    if (res.done) doneR2.add(c);
  }

  const allSubDone = (doneR2.size === 3);
  const subRemain = SUBCITIES.filter(c=>!doneR2.has(c));

  // After subcities (if done), spend remaining b2 into Rex (alive=0)
  let rexRemainAfterR2 = null;
  if (allSubDone && b2 > 0){
    const rexState = buildRexWork(setups.Rex, 0, 0);
    const rexSpend = spendRexForRound(rexState, b2, 0);
    r2Steps.push(...rexSpend.steps);

    let rem = 0;
    for (const it of rexState) rem += it.remaining;
    rexRemainAfterR2 = rem;

    if (rem > 1e-9){
      r2Steps.push({ label:`Rex remaining after R2`, spent: Math.round(rem*1000)/1000 });
    }
  } else if (allSubDone) {
    // no budget left for Rex at all
    rexRemainAfterR2 = totalRexCost;
    r2Steps.push({ label:`Rex remaining after R2`, spent: Math.round(totalRexCost*1000)/1000 });
  }

  // Required in R2 to win = remainingSubCostAfterR1 + totalRexCost
  const subReqR2 = Math.max(0, totalSubCost - r1Used);
  const r2Req = subReqR2 + totalRexCost;

  const feasible = (totalSubCost <= 2*perRound + 1e-9) && (r2Req <= perRound + 1e-9);

  return {
    k:3,
    order,
    S1,
    S2: SUBCITIES.filter(c=>doneR2.has(c) && !doneR1.has(c)),
    r1Used,
    r1Spend:{ spentTotal: r1Used, unusedBudget: r1Waste },
    r2Req,
    totalReq,
    feasible,
    r2Over: Math.max(0, r2Req - perRound),
    r2Slack: Math.max(0, perRound - r2Req),
    r1Steps,
    r2Steps,
    allSubDone,
    subRemain
  };
}

/* =======================
   RENDER
   ======================= */
function fmt(n){ return String(Math.round(n*1000)/1000); }

function computeRoutes(){
  for (const city of CITY_ORDER){
    const setup = getCitySetup(city);
    const used = totalDefenders(setup);
    if (used > CITY_LIMITS[city]){
      return { ok:false, error:`${city} too many (${used}/${CITY_LIMITS[city]}).` };
    }
  }

  const attackers = clampInt(parseInt(document.getElementById("attackers").value,10), 1, 999999);
  const perRound = attackers * ATTACKS_PER_ATTACKER_PER_ROUND;

  const setups = {
    Astra: getCitySetup("Astra"),
    Luna:  getCitySetup("Luna"),
    Sola:  getCitySetup("Sola"),
    Rex:   getCitySetup("Rex")
  };

  const cityClear = {};
  for (const c of SUBCITIES) cityClear[c] = fullClearSubcity(c, setups[c]);

  return {
    ok:true,
    perRound,
    routes:{
      1: computeBestForK(setups, cityClear, perRound, 1),
      2: computeBestForK(setups, cityClear, perRound, 2),
      3: computeBestFor3(setups, perRound)
    }
  };
}

function fillPanel(k, plan, perRound){
  const outEl = document.getElementById(`k${k}_out`);
  const boxEl = document.getElementById(`k${k}_boxes`);

  if (!plan){
    boxEl.innerHTML = "";
    outEl.textContent = "No plan found.";
    return;
  }

  boxEl.innerHTML = `
    <div class="miniBox"><b>Feasible</b><div>${plan.feasible ? "YES" : "NO"}</div></div>
    <div class="miniBox"><b>R2 Over</b><div>${plan.r2Over > 0 ? "+"+fmt(plan.r2Over) : "0"}</div></div>
    <div class="miniBox"><b>R2 Slack</b><div>${plan.r2Slack > 0 ? fmt(plan.r2Slack) : "0"}</div></div>
    <div class="miniBox"><b>Total Req</b><div>${fmt(plan.totalReq)}</div></div>
  `;

  const lines=[];
  lines.push(`perRound=${perRound}`);

  if (k === 3){
    lines.push(`R1 subcities only`);
    lines.push(`Order: ${plan.order.join(" -> ")}`);
    lines.push(`R1 done: [${plan.S1.join(", ")||"none"}]`);
    lines.push(`R2 finish subcities, then Rex (alive=0)`);
    if (plan.subRemain.length) lines.push(`Remaining after R2: [${plan.subRemain.join(", ")}]`);
  } else {
    lines.push(`R1 destroy=[${plan.S1.join(", ")||"none"}], dump Rex (alive=${plan.aliveA1})`);
    lines.push(`R2 destroy=[${plan.S2.join(", ")||"none"}], finish Rex (alive=${plan.aliveA2})`);
  }

  lines.push("");
  lines.push(`R1 used: ${fmt(plan.r1Used)} / ${perRound} (waste=${fmt(plan.r1Spend.unusedBudget||0)})`);
  lines.push(`R2 required: ${fmt(plan.r2Req)} / ${perRound}`);
  lines.push(`Total required: ${fmt(plan.totalReq)}`);
  lines.push("");
  lines.push(`R1 steps:`);
  for (const s of plan.r1Steps) lines.push(`- ${s.label}: ${fmt(s.spent)}`);
  lines.push("");
  lines.push(`R2 steps:`);
  for (const s of plan.r2Steps) lines.push(`- ${s.label}: ${fmt(s.spent)}`);

  outEl.textContent = lines.join("\n");
}

function render(){
  const status = document.getElementById("status");
  const res = computeRoutes();

  if (!res.ok){
    status.innerHTML = `<span class="bad">Error</span> — ${res.error}`;
    ["k1","k2","k3"].forEach(id=>{
      document.getElementById(`${id}_boxes`).innerHTML = "";
      document.getElementById(`${id}_out`).textContent = res.error;
    });
    return;
  }

  status.innerHTML = `<span class="ok">OK</span> — perRound=${res.perRound}`;

  fillPanel(1, res.routes[1], res.perRound);
  fillPanel(2, res.routes[2], res.perRound);
  fillPanel(3, res.routes[3], res.perRound);
}

/* =======================
   MOUNT
   ======================= */
function mount(){
  attackersOptions();
  document.getElementById("cities").innerHTML = CITY_ORDER.map(cityBlock).join("");

  const defaults = {
    Astra:{ barrier:"1w", other:{ "3w":9,"2w":0,"1w":0,"0w":0 } },
    Luna: { barrier:"1w", other:{ "3w":9,"2w":0,"1w":0,"0w":0 } },
    Sola: { barrier:"1w", other:{ "3w":8,"2w":0,"1w":0,"0w":0 } },
    Rex:  { barrier:"1w", other:{ "3w":14,"2w":0,"1w":0,"0w":0 } },
  };

  for (const name of CITY_ORDER){
    updateDropdownMax(name);
    document.getElementById(`${name}_barrier`).value = defaults[name].barrier;

    const maxOther = Math.max(0, CITY_LIMITS[name]-1);
    for (const w of W_LEVELS){
      const v = Math.min(defaults[name].other[w], maxOther);
      document.getElementById(`${name}_other_${w}`).value = String(v);
    }

    const ids = [ `${name}_barrier`, `${name}_other_3w`, `${name}_other_2w`, `${name}_other_1w`, `${name}_other_0w` ];
    ids.forEach(id => document.getElementById(id).addEventListener("change", ()=>{
      updateDropdownMax(name);
      updateRemaining(name);
    }));
    updateRemaining(name);
  }

  document.getElementById("calcBtn").addEventListener("click", render);

  document.querySelectorAll(".tabBtn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const tab = btn.getAttribute("data-tab");
      document.querySelectorAll(".tabBtn").forEach(b=>b.classList.toggle("active", b===btn));
      document.querySelectorAll(".tabPanel").forEach(p=>p.classList.toggle("active", p.id===tab));
    });
  });
}

mount();
</script>
</body>
</html>
