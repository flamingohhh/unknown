<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GVG Optimal Attack Planner</title>
  <style>
    :root{
      --border:#e6e6e7; --text:#111; --muted:#666; --bg:#fff;
      --astra:#2563eb; --luna:#7c3aed; --sola:#16a34a; --rex:#dc2626;
      --w3:#e11d48; --w2:#f59e0b; --w1:#22c55e; --w0:#64748b;
    }
    *{ box-sizing:border-box; }
    body{ font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:14px; color:var(--text); background:var(--bg); }
    h1{ margin:0 0 10px; font-size:18px; }
    h2{ margin:14px 0 8px; font-size:15px; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .card{ border:1px solid var(--border); border-radius:14px; padding:12px; margin:10px 0; background:#fff; box-shadow:0 1px 0 rgba(0,0,0,.03); }
    label{ display:block; font-size:12px; margin-bottom:6px; }
    input, select{
      width:100%;
      padding:10px 12px;
      border:1px solid #d7d7da;
      border-radius:12px;
      font-size:14px;
      background:#fff;
    }
    button{
      width:100%;
      padding:12px 14px;
      border:0;
      border-radius:14px;
      background:#111;
      color:#fff;
      font-weight:700;
      font-size:15px;
      cursor:pointer;
    }
    button:hover{ opacity:.92; }
    pre{ background:#0b0b0b; color:#eaeaea; padding:12px; border-radius:14px; overflow:auto; white-space:pre-wrap; font-size:12px; }
    .ok{ color:#0b7a0b; font-weight:700; }
    .bad{ color:#b00020; font-weight:700; }

    .cityCard{ border-left:8px solid transparent; }
    .cityCard.astra{ border-left-color:var(--astra); }
    .cityCard.luna{ border-left-color:var(--luna); }
    .cityCard.sola{ border-left-color:var(--sola); }
    .cityCard.rex{ border-left-color:var(--rex); }

    .cityHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .cityTitle{
      display:flex; align-items:center; gap:10px;
      font-weight:800; font-size:14px;
    }
    .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
    .dot.astra{ background:var(--astra); }
    .dot.luna{ background:var(--luna); }
    .dot.sola{ background:var(--sola); }
    .dot.rex{ background:var(--rex); }
    .slots{ font-size:12px; color:var(--muted); white-space:nowrap; }

    /* Layout */
    .row{ display:grid; grid-template-columns: 1fr; gap:10px; }
    @media (min-width: 900px){
      body{ margin:18px; }
      h1{ font-size:20px; }
      .row{ grid-template-columns: 1fr 1fr; }
    }

    .helperLine{ margin-top:8px; font-size:12px; font-weight:700; }
    .helperLine.ok{ color:#0b7a0b; }
    .helperLine.bad{ color:#b00020; }

    /* compact dropdown line for 3w/2w/1w/0w */
    .kLine{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:8px;
      margin-top:10px;
    }
    .kField label{
      margin-bottom:4px;
      font-size:11px;
      display:flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
    }
    .kField select{
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
    }
    .kd{ width:10px; height:10px; border-radius:999px; display:inline-block; }
    .kd.w3{ background:var(--w3); }
    .kd.w2{ background:var(--w2); }
    .kd.w1{ background:var(--w1); }
    .kd.w0{ background:var(--w0); }
  </style>
</head>
<body>
  <h1>GVG Optimal Attack Planner</h1>

  <div class="card">
    <h2>Attackers</h2>
    <div class="row">
		<label>Number of attackers</label>
		<select id="attackers"></select>
    </div>
  </div>

  <div class="card">
    <h2>City Setup</h2>
    <div class="muted" style="margin-bottom:10px;">
      Barrier Kraken must die first. Rex special gate: Rex barrier structure must be destroyed after Rex barrier Kraken before any other Rex target is attackable.
    </div>
    <div id="cities"></div>
    <div style="margin-top:10px;">
      <button id="calcBtn">Calculate best plan</button>
    </div>
  </div>

  <div class="card">
    <h2>Output</h2>
    <div id="status" class="muted">Press “Calculate best plan”.</div>
    <pre id="out"></pre>
  </div>

<script>
/** ------------------------
 *  Core rules (unchanged)
 *  ------------------------
 */
const ATTACKS_PER_ATTACKER_PER_ROUND = 10;

const NORMAL_DEF_COST = { "3w":10, "2w":15, "1w":20, "0w":60 };
const REX_OTHER_DEF_COST_BY_ALIVE = {
  3: { "3w":100, "2w":150, "1w":200, "0w":600 },
  2: { "3w":25,  "2w":38,  "1w":50,  "0w":150 },
  1: { "3w":15,  "2w":22,  "1w":28,  "0w":75  },
  0: { "3w":10,  "2w":15,  "1w":20,  "0w":60  }
};
const CITY_STRUCT = {
  Astra: { outposts:7, camps:3, barrier:1 },
  Luna:  { outposts:7, camps:3, barrier:1 },
  Sola:  { outposts:9, camps:3, barrier:1 },
  Rex:   { outposts:11, camps:3, barrier:1 }
};
const CITY_LIMITS = { Astra:11, Luna:11, Sola:13, Rex:15 };
const STRUCT_COST = { outpost:5, camp:10, barrier:5 };
const REX_STRUCT_COST_BY_ALIVE = {
  3: { outpost:50, camp:100, barrier:5 },
  2: { outpost:13, camp:25,  barrier:5 },
  1: { outpost:8,  camp:15,  barrier:5 },
  0: { outpost:5,  camp:10,  barrier:5 }
};

const W_LEVELS = ["3w","2w","1w","0w"];
const CITY_ORDER = ["Astra","Luna","Sola","Rex"];
const SUBCITIES = ["Astra","Luna","Sola"];
const CITY_CLASS = { Astra:"astra", Luna:"luna", Sola:"sola", Rex:"rex" };

/** ------------------------
 *  Dropdown helpers
 *  ------------------------
 */
function optionList(max, selected){
  let html = "";
  for (let i=0;i<=max;i++){
    html += `<option value="${i}" ${i===selected?"selected":""}>${i}</option>`;
  }
  return html;
}
function attackersOptions(){
  const sel = document.getElementById("attackers");
  let html="";
  for (let i=1;i<=100;i++){
    html += `<option value="${i}" ${i===44?"selected":""}>${i}</option>`;
  }
  sel.innerHTML = html;
}
function barrierSelect(id){
  return `
    <select id="${id}">
      <option value="none">No barrier Kraken</option>
      <option value="3w">Barrier 3w</option>
      <option value="2w">Barrier 2w</option>
      <option value="1w">Barrier 1w</option>
      <option value="0w">Barrier 0w</option>
    </select>
  `;
}
function cityBlock(name){
  const limit = CITY_LIMITS[name];
  const cls = CITY_CLASS[name];
  return `
    <div class="card cityCard ${cls}">
      <div class="cityHeader">
        <div class="cityTitle"><span class="dot ${cls}"></span>${name}</div>
        <div class="slots">Slots: <b id="${name}_slotsUsed">0</b> / ${limit}</div>
      </div>

      <div class="row">
        <div>
          <label>Barrier Kraken</label>
          ${barrierSelect(`${name}_barrier`)}
        </div>

        <div>
          <label>Other Krakens</label>

          <div class="kLine">
            <div class="kField">
              <label><span class="kd w3"></span>3w</label>
              <select id="${name}_other_3w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w2"></span>2w</label>
              <select id="${name}_other_2w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w1"></span>1w</label>
              <select id="${name}_other_1w"></select>
            </div>
            <div class="kField">
              <label><span class="kd w0"></span>0w</label>
              <select id="${name}_other_0w"></select>
            </div>
          </div>

          <div class="helperLine" id="${name}_remaining"></div>
        </div>
      </div>
    </div>
  `;
}

/** ------------------------
 *  Read state + slot checks
 *  ------------------------
 */
function clampInt(v, lo, hi){
  v = Number.isFinite(v) ? Math.floor(v) : lo;
  return Math.max(lo, Math.min(hi, v));
}
function getCitySetup(name){
  const barrierVal = document.getElementById(`${name}_barrier`).value;
  const barrier = (barrierVal === "none") ? null : barrierVal;
  const other = {};
  for (const w of W_LEVELS){
    const raw = parseInt(document.getElementById(`${name}_other_${w}`).value,10);
    other[w] = clampInt(raw, 0, 999);
  }
  return { barrier, other };
}
function totalDefenders(setup){
  let sum = 0;
  for (const w of W_LEVELS) sum += (setup.other[w]||0);
  if (setup.barrier) sum += 1;
  return sum;
}
function updateDropdownMax(name){
  // Reserve 1 slot for the barrier (even if "none"), so other max = total-1
  const limit = CITY_LIMITS[name];
  const maxOther = Math.max(0, limit - 1);

  for (const w of W_LEVELS){
    const el = document.getElementById(`${name}_other_${w}`);
    const cur = clampInt(parseInt(el.value,10), 0, 999);
    const safe = Math.min(cur, maxOther);
    el.innerHTML = optionList(maxOther, safe);
  }
}
function updateRemaining(name){
  const setup = getCitySetup(name);
  const used = totalDefenders(setup);
  const limit = CITY_LIMITS[name];
  const remaining = limit - used;

  document.getElementById(`${name}_slotsUsed`).textContent = used;

  const el = document.getElementById(`${name}_remaining`);
  if (remaining >= 0){
    el.className = "helperLine ok";
    el.innerHTML = `Remaining slots: <b>${remaining}</b>`;
  } else {
    el.className = "helperLine bad";
    el.innerHTML = `Too many Krakens — reduce by <b>${-remaining}</b>`;
  }
}

/** ------------------------
 *  Calculation engine (same as before)
 *  ------------------------
 */
function subcityStructureCost(city){
  const c = CITY_STRUCT[city];
  return c.outposts*STRUCT_COST.outpost + c.camps*STRUCT_COST.camp + c.barrier*STRUCT_COST.barrier;
}
function fullClearSubcity(city, setup){
  const parts = [];
  let total = 0;

  if (setup.barrier){
    const cost = NORMAL_DEF_COST[setup.barrier];
    parts.push({ label:`Kill ${city} barrier Kraken (${setup.barrier})`, cost });
    total += cost;
  }
  for (const w of W_LEVELS){
    const n = setup.other[w] || 0;
    if (n>0){
      const cost = n * NORMAL_DEF_COST[w];
      parts.push({ label:`Kill ${city} ${w} Krakens ×${n}`, cost });
      total += cost;
    }
  }
  const structCost = subcityStructureCost(city);
  parts.push({ label:`Destroy ${city} structures`, cost: structCost });
  total += structCost;

  return { total, parts };
}

function buildRexWork(setupRex, aliveA1, aliveA2){
  const work = [];
  if (setupRex.barrier){
    const cost = NORMAL_DEF_COST[setupRex.barrier];
    work.push({ stage:0, key:"rex_gate_kraken", label:`Kill Rex barrier Kraken (${setupRex.barrier})`, remaining: cost });
  }
  const barrierStructCost = REX_STRUCT_COST_BY_ALIVE[aliveA1].barrier; // 5
  work.push({ stage:1, key:"rex_gate_barrier_struct", label:`Destroy Rex barrier structure`, remaining: barrierStructCost });

  for (const w of W_LEVELS){
    const n = setupRex.other[w] || 0;
    if (n<=0) continue;
    const per1 = REX_OTHER_DEF_COST_BY_ALIVE[aliveA1][w];
    const per2 = REX_OTHER_DEF_COST_BY_ALIVE[aliveA2][w];
    for (let i=0;i<n;i++){
      work.push({ stage:2, key:`rex_def_${w}_${i}`, labelBase:`Kill Rex ${w} Kraken`, w, remaining: per1, per1, per2 });
    }
  }

  const out1 = REX_STRUCT_COST_BY_ALIVE[aliveA1].outpost;
  const out2 = REX_STRUCT_COST_BY_ALIVE[aliveA2].outpost;
  for (let i=0;i<CITY_STRUCT.Rex.outposts;i++){
    work.push({ stage:2, key:`rex_outpost_${i}`, labelBase:`Destroy Rex outpost`, remaining: out1, per1: out1, per2: out2 });
  }

  const camp1 = REX_STRUCT_COST_BY_ALIVE[aliveA1].camp;
  const camp2 = REX_STRUCT_COST_BY_ALIVE[aliveA2].camp;
  for (let i=0;i<CITY_STRUCT.Rex.camps;i++){
    work.push({ stage:2, key:`rex_camp_${i}`, labelBase:`Destroy Rex camp`, remaining: camp1, per1: camp1, per2: camp2 });
  }

  return work;
}

function spendRexForRound(workState, budget, aliveLabel){
  let spentTotal = 0;
  const steps = [];
  const spendInto = (item, amount, label) => {
    const use = Math.min(amount, item.remaining);
    if (use<=0) return 0;
    item.remaining -= use;
    spentTotal += use;
    steps.push({ label: label + (item.remaining>0 ? " (partial)" : ""), spent: use });
    return use;
  };

  const gate0 = workState.find(x=>x.stage===0);
  if (gate0 && gate0.remaining>0 && budget>0){
    const used = spendInto(gate0, budget, gate0.label);
    budget -= used;
  }
  const gate0Complete = !gate0 || gate0.remaining===0;
  const gate1 = workState.find(x=>x.stage===1);
  if (gate0Complete && gate1.remaining>0 && budget>0){
    const used = spendInto(gate1, budget, gate1.label);
    budget -= used;
  }
  const gate1Complete = gate1.remaining===0;

  if (gate0Complete && gate1Complete && budget>0){
    const stage2 = workState.filter(x=>x.stage===2 && x.remaining>0);
    stage2.sort((a,b)=>{
      const da = (a.per1-a.per2), db = (b.per1-b.per2);
      if (da!==db) return da-db;
      const pa = a.key.startsWith("rex_def_") ? 0 : 1;
      const pb = b.key.startsWith("rex_def_") ? 0 : 1;
      return pa-pb;
    });
    for (const it of stage2){
      if (budget<=0) break;
      const used = spendInto(it, budget, `${it.labelBase} (aliveSub=${aliveLabel})`);
      budget -= used;
    }
  }
  return { spentTotal, steps, unusedBudget: budget };
}

function rexRemainingCostForRound2(workState){
  let total=0;
  for (const it of workState){
    if (it.stage===0 || it.stage===1){
      total += it.remaining;
    } else {
      const frac = it.per1>0 ? (it.remaining/it.per1) : 0;
      total += frac * it.per2;
    }
  }
  return total;
}

function allSubsets(arr){
  const out=[], n=arr.length;
  for (let mask=0; mask<(1<<n); mask++){
    const s=[];
    for (let i=0;i<n;i++) if (mask&(1<<i)) s.push(arr[i]);
    out.push(s);
  }
  return out;
}

function computeBestPlan(){
  for (const city of CITY_ORDER){
    const setup = getCitySetup(city);
    const used = totalDefenders(setup);
    if (used > CITY_LIMITS[city]) return { ok:false, error:`${city} has too many Krakens (${used}/${CITY_LIMITS[city]}).` };
  }

  const attackers = clampInt(parseInt(document.getElementById("attackers").value,10), 1, 999999);
  const perRound = attackers * ATTACKS_PER_ATTACKER_PER_ROUND;
  const totalAvailable = perRound * 2;

  const setups = {
    Astra: getCitySetup("Astra"),
    Luna:  getCitySetup("Luna"),
    Sola:  getCitySetup("Sola"),
    Rex:   getCitySetup("Rex")
  };
  const cityClear = {};
  for (const c of SUBCITIES) cityClear[c] = fullClearSubcity(c, setups[c]);

  let best=null;
  for (const S1 of allSubsets(SUBCITIES)){
    const costS1 = S1.reduce((a,c)=>a+cityClear[c].total,0);
    if (costS1>perRound) continue;

    const rem = SUBCITIES.filter(c=>!S1.includes(c));
    for (const S2 of allSubsets(rem)){
      const costS2 = S2.reduce((a,c)=>a+cityClear[c].total,0);
      if (costS2>perRound) continue;

      const aliveA1 = 3 - S1.length;
      const aliveA2 = 3 - S1.length - S2.length;

      const b1Rex = perRound - costS1;
      const b2Rex = perRound - costS2;

      const rexState = buildRexWork(setups.Rex, aliveA1, aliveA2);

      const r1Spend = spendRexForRound(rexState, b1Rex, aliveA1);

      const rexNeedR2 = rexRemainingCostForRound2(rexState);
      if (rexNeedR2 > b2Rex + 1e-9) continue;

      const r2Spend = spendRexForRound(rexState, b2Rex, aliveA2);
      const rexLeft = rexRemainingCostForRound2(rexState);
      if (rexLeft > 1e-6) continue;

      const rexR1 = r1Spend.spentTotal;
      const rexR2 = b2Rex - r2Spend.unusedBudget;
      const totalUseful = costS1 + costS2 + rexR1 + rexR2;
      if (totalUseful > totalAvailable + 1e-9) continue;

      const slackR2 = r2Spend.unusedBudget;
      const slackTotal = totalAvailable - totalUseful;

      const score = { totalUseful, slackTotal, slackR2 };
      const better = (!best)
        || score.totalUseful < best.score.totalUseful
        || (score.totalUseful===best.score.totalUseful && score.slackTotal>best.score.slackTotal)
        || (score.totalUseful===best.score.totalUseful && score.slackTotal===best.score.slackTotal && score.slackR2>best.score.slackR2);
      if (!better) continue;

      const r1Steps=[], r2Steps=[];
      for (const c of SUBCITIES) if (S1.includes(c)) r1Steps.push(...cityClear[c].parts.map(p=>({label:p.label,spent:p.cost})));
      r1Steps.push(...r1Spend.steps);

      for (const c of SUBCITIES) if (S2.includes(c)) r2Steps.push(...cityClear[c].parts.map(p=>({label:p.label,spent:p.cost})));
      r2Steps.push(...r2Spend.steps);

      best = {
        ok:true, score,
        attackers, perRound, totalAvailable,
        S1, S2, aliveA1, aliveA2,
        costS1, costS2,
        rexR1, rexR2,
        rexRemainingAfterR1: rexNeedR2,
        r1Waste: r1Spend.unusedBudget,
        slackR2, slackTotal, totalUseful,
        r1Steps, r2Steps
      };
    }
  }

  if (!best) return { ok:false, error:"No feasible plan found under the updated rules within 2 rounds." };
  return best;
}

function render(){
  const status = document.getElementById("status");
  const out = document.getElementById("out");

  const res = computeBestPlan();
  if (!res.ok){
    status.innerHTML = `<span class="bad">Not feasible</span> — ${res.error}`;
    out.textContent = res.error;
    return;
  }

  const lines=[];
  lines.push(`Feasible: YES`);
  lines.push(`Best plan:`);
  lines.push(`  Round 1 destroy: [${res.S1.join(", ")||"none"}], then dump remaining into Rex (aliveSub=${res.aliveA1})`);
  lines.push(`  Round 2 destroy: [${res.S2.join(", ")||"none"}], then finish Rex (aliveSub=${res.aliveA2})`);
  lines.push("");
  lines.push(`Round 1 (budget ${res.perRound}):`);
  lines.push(`  Subcity cost: ${res.costS1}`);
  lines.push(`  Rex progress: ${res.rexR1}`);
  lines.push(`  Attacks used: ${res.costS1 + res.rexR1} / ${res.perRound}`);
  lines.push(`  Rex remaining after Round 1: ${Math.round(res.rexRemainingAfterR1*1000)/1000}`);
  if (res.r1Waste>0) lines.push(`  NOTE: Unavoidable Round-1 waste (Rex already dead): ${res.r1Waste}`);
  lines.push("");
  lines.push(`  Round 1 attack order:`);
  for (const s of res.r1Steps) lines.push(`    - ${s.label}: ${s.spent} attacks`);

  lines.push("");
  lines.push(`Round 2 (budget ${res.perRound}):`);
  lines.push(`  Subcity cost: ${res.costS2}`);
  lines.push(`  Rex finish: ${res.rexR2}`);
  lines.push(`  Attacks used: ${res.costS2 + res.rexR2} / ${res.perRound}`);
  lines.push(`  Slack after Rex dies: ${res.slackR2}`);
  lines.push("");
  lines.push(`  Round 2 attack order:`);
  for (const s of res.r2Steps) lines.push(`    - ${s.label}: ${s.spent} attacks`);

  lines.push("");
  lines.push(`Totals:`);
  lines.push(`  Total attacks required (useful): ${Math.round(res.totalUseful*1000)/1000}`);
  lines.push(`  Total slack over 2 rounds: ${Math.round(res.slackTotal*1000)/1000}`);

  status.innerHTML = `<span class="ok">Feasible</span>`;
  out.textContent = lines.join("\n");
}

/** Mount */
function mount(){
  attackersOptions();
  document.getElementById("cities").innerHTML = CITY_ORDER.map(cityBlock).join("");

  // Defaults
  const defaultOther = {
    Astra:{ "3w":9,"2w":0,"1w":0,"0w":0 },
    Luna: { "3w":9,"2w":0,"1w":0,"0w":0 },
    Sola: { "3w":8,"2w":0,"1w":0,"0w":0 },
    Rex:  { "3w":14,"2w":0,"1w":0,"0w":0 },
  };

  for (const name of CITY_ORDER){
    document.getElementById(`${name}_barrier`).value = "1w";

    // dropdown max = limit-1
    updateDropdownMax(name);

    // set defaults after max
    const maxOther = Math.max(0, CITY_LIMITS[name]-1);
    for (const w of W_LEVELS){
      document.getElementById(`${name}_other_${w}`).value = String(Math.min(defaultOther[name][w], maxOther));
    }

    const ids = [ `${name}_barrier`, `${name}_other_3w`, `${name}_other_2w`, `${name}_other_1w`, `${name}_other_0w` ];
    ids.forEach(id => document.getElementById(id).addEventListener("change", ()=>{
      updateDropdownMax(name);
      updateRemaining(name);
    }));
    updateRemaining(name);
  }

  document.getElementById("calcBtn").addEventListener("click", render);
}

mount();
</script>
</body>
</html>
